<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Fewbytes</title><link href="http://fonts.googleapis.com/css?family=Gentium+Basic:400,700,400italic" rel=stylesheet type=text/css><link href="http://fonts.googleapis.com/css?family=Open+Sans:700,400" rel=stylesheet type=text/css><link rel=alternate type=application/rss+xml title="Fewbytes &#187; Feed" href=http://www.fewbytes.com/feed/><link rel=alternate type=application/rss+xml title="Fewbytes &#187; Comments Feed" href=http://www.fewbytes.com/comments/feed/><script type=text/javascript>window._wpemojiSettings={"baseUrl":"http:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/www.fewbytes.com\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.3.1"}};!function(a,b,c){function d(a){var c=b.createElement("canvas"),d=c.getContext&&c.getContext("2d");return d&&d.fillText?(d.textBaseline="top",d.font="600 32px Arial","flag"===a?(d.fillText(String.fromCharCode(55356,56812,55356,56807),0,0),c.toDataURL().length>3e3):(d.fillText(String.fromCharCode(55357,56835),0,0),0!==d.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);</script><style type=text/css>img.wp-smiley,img.emoji{display:inline!important;border:none!important;box-shadow:none!important;height:1em!important;width:1em!important;margin:0 .07em!important;vertical-align:-.1em!important;background:0 0!important;padding:0!important}</style><link rel=stylesheet id=parent-style-css href=/css/style.css type=text/css media=all><link rel=stylesheet id=brosco-style-css href=/css/style2.css type=text/css media=all><script type=text/javascript src=http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js></script></head><body class="page-template-default group-blog"><div id=page class="hfeed site"><a class="skip-link screen-reader-text" href=#content>Skip to content</a><header id=masthead class=site-header role=banner><div class=header-inside><div class=logo><a href=http://www.fewbytes.com/ title=Fewbytes rel=home><img src=http://www.fewbytes.com/wp-content/uploads/2015/11/fewbytes-logo1.png alt=Fewbytes></a></div><nav id=site-navigation class=main-navigation role=navigation><button class=menu-toggle>Primary Menu</button><div class=menu-top-bar-container><ul id=menu-top-bar class=menu><li id=menu-item-374 class="menu-item menu-item-type-post_type menu-item-object-page current-menu-item page_item page-item-77 current_page_item menu-item-374"><a href=/>Home</a></li><li id=menu-item-89 class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-89"><a href=/posts/>Blog</a></li></ul></div></nav></header><div id=content class=site-content><section id=primary class=content-area><main class=site-main><div class=single-post><div class=container><article class="post type-post status-publish"><header class=entry-header><h1 class=entry-title>The Problem With Configurations</h1><div class=entry-meta><time class="entry-date published posted-on">June 13, 2015</time> | <span class=entry-author>Avishai Ish-Shalom</span></div></header><div class=entry-content><p><em>Originally published in <a href=http://www.netocratic.com/devops-the-problem-with-configurations-89297>Netocratic</a></em></p><p><strong>Configuration</strong> is one of those things we usually take for granted. Yet, as more and more configurations are added the use of configurations becomes hard and complicated. With enough configuration parameters, keeping track of what the current configuration “is” can be quite problematic. Often, people misconfigure systems due to various reasons such as poor documentation or unexpected interactions between different parameters. Sometimes, the configuration itself can be complex and requires a language to express it, raising the bar of required knowledge for defining the configuration. Despite the “boring” nature of configurations they can and do <a href=http://dealbook.nytimes.com/2012/08/02/knight-capital-says-trading-mishap-cost-it-440-million>obliterate entire companies in matter of hours</a>.</p><h2 id=yet-another-config-format>Yet another config format</h2><p>If you take a quick look in your /etc/ directory you will find a pile of configuration files using a large variety of format. From key/value shell include files through ini, toml, json, yaml, xml – and those are the relatively standard ones; If you care to look at sudoers, apt.conf, apache or postfix for example you will find more weird looking formats.</p><p>Unfortunately we humans need to remember the syntax for each format, not to mention other pecularities of each program configurations. For example, there is no standard for config file validation and some programs don’t have validation at all!</p><p>The vast variety of config formats makes system administration harder. It is hard to keep track and maintain a decent skill; some formats are very hard to generate from configuration management tools and scripts so we must resort to using error prone text templates.</p><h2 id=configuration-drop-bomb>Configuration drop bomb</h2><p>The conf.d pattern has emerged many years ago as a way to allow different modules and packages to inject configuration snippets to other programs. In the absent of CM tools, it served humans to split large configurations to make management easier.</p><p>This pattern is generally considered a good practice yet it causes surprising amount of difficulty in maintenance and automation of systems. Since configurations are merged, values can be overridden from other files and are sometimes merged in unexpected ways. You change a configuration parameter, yet the program behaves as if you changed nothing; you grep through the directory and find this value has been set in a different file, one which you do not control. You must reason about the merge order and move your file to a higher priority, possibly overriding other parameters… and now you need to debug again.</p><p>When using CM tools this pattern is particularly annoying – if your CM tool manage files in the conf.d directory and you later remove these file resources the configuration files are not removed, they are simply no longer managed. Moreover, this allows overriding the automatic configurations by dropping files into conf.d manually, circumventing our effort to standardise configurations in servers.</p><h2 id=dude-did-you-restart-just-now>Dude, did you restart just now?</h2><p>Traditionally, config reload is done by sending a POSIX signal to the process, usually USR1 or HUP. The problem is that signal have no output and there is no obvious feedback telling us whether our reload succeeded. Perhaps the config file is malformed or we have set some parameter to an invalid value; Perhaps the signal was blocked or the program couldn’t handle it. We simply don’t know until we start digging through log files and even then we can’t be sure since the absent of “reload” message in the log file doesn’t actually mean the reload didn’t happen. On top of that it’s extremely difficult to automate such checks, so in most cases we simply give up and assume the configuration made it to our program or take the brutal approach and restart our process needlessly.</p><h2 id=when-in-doubt-nuke-from-orbit>When in doubt, nuke from orbit</h2><p>Some parameters that require a restart to change and some require a reload. CM tools have no way to identify what parameters changed in your configuration file and whether a reload is sufficient to activate the changes. As a result, we are forced to always use the nuclear option – restart. Unfortunately sometimes even the nukes are not enough, such as when changing MySQL innodb ibdata file size – which requires a stop – maintenance – start cycle; This forces us to resort to “nuke from orbit” methods of tearing down compute instances to support a configuration change.</p><h2 id=i-have-no-idea-whats-going-on>I have no idea what’s going on</h2><p>Just because the config file contains value X doesn’t actually mean that’s what loaded in the process. Perhaps the file was changed without reloading the configuration or the configuration path is wrong – this is actually very common. So how do you know what configuration is loaded in your server? how do you validate that all servers are configured properly? Most programs do not provide a good mechanism for this.</p><h1 id=a-better-way>A better way</h1><p>Like most operational aspects of programs, configuration issues can and should be resolved by grassroots engineering work rather then after-the-fact makeshift solutions. A good example of an attempt to tackle this at the core is <a href=https://github.com/Netflix/archaius>Netflix Archaius</a> project and many others have followed suite.</p><p>There are several simple design principles that can help make the configuration of your program much easier to work with. To some degree, <strong>you can even apply these principle to 3rd party programs</strong> using CM tools:</p><ul><li><strong>Separate configuration to 2-3</strong> files based on the impact of configuration parameter change: 1st file contains parameters that require a restart to change, 2nd contains parameters that require a reload and so on.</li><li><strong>Avoid using the <code>conf.d</code> pattern.</strong> Instead, have your CM tools merge values and create a small number of config files – making debugging and validation easier</li><li><strong>Create a configuration API.</strong> If using REST, GET method should return a complete dump of configuration parameters with e-tag header, and HEAD should return the e-tag header without a body. <strong>The e-tag header should be a checksum of the configuration</strong> in canonical order allowing for easy comparison between in-ram configuration of all nodes and reference version in CM</li><li>If possible, use the REST configuration API to <strong>reload configurations using a POST or PUT</strong> requests. This allows your CM tools to easily validate that the configuration was successfully loaded and whether any values were updated (200/201/202 response). If not possible, write a small reload wrapper that verifies configuration was reloaded using whatever feedback the program provides.</li><li>When writing new programs, <strong>choose a serialiazed format for configuration</strong> like json, yaml, edn, etc. Although they are not particularly comfortable for users to work with directly, remember that using CM tools and simple utilities people can work with whatever format they feel comformtable with as a long as a conversion utility exists.</li><li>Some programs require advanced configuration employing logic (e.g. logstash) which doesn’t easily map to serialized formats; For these, <strong>treat the configuration as a plugin and extract variables to an external configuration file.</strong></li></ul></div></article></div><nav class="navigation post-navigation" role=navigation><h1 class=screen-reader-text>Post navigation</h1><div class=nav-links style=display:block><div class=nav-previous><a href=/docker-selinux-and-the-myth-of-kernel-independence/ rel=prev><span class=meta-nav></span>Previous</a></div><div class=nav-next></div></div></nav></div></main></section></div><footer id=colophon class=site-footer role=contentinfo><div class=site-info>&copy; Fewbytes</div></footer></div></body></html>