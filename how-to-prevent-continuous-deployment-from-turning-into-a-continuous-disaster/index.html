<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Fewbytes</title><link href="http://fonts.googleapis.com/css?family=Gentium+Basic:400,700,400italic" rel=stylesheet type=text/css><link href="http://fonts.googleapis.com/css?family=Open+Sans:700,400" rel=stylesheet type=text/css><link rel=alternate type=application/rss+xml title="Fewbytes &#187; Feed" href=http://www.fewbytes.com/feed/><link rel=alternate type=application/rss+xml title="Fewbytes &#187; Comments Feed" href=http://www.fewbytes.com/comments/feed/><script type=text/javascript>window._wpemojiSettings={"baseUrl":"http:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/www.fewbytes.com\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.3.1"}};!function(a,b,c){function d(a){var c=b.createElement("canvas"),d=c.getContext&&c.getContext("2d");return d&&d.fillText?(d.textBaseline="top",d.font="600 32px Arial","flag"===a?(d.fillText(String.fromCharCode(55356,56812,55356,56807),0,0),c.toDataURL().length>3e3):(d.fillText(String.fromCharCode(55357,56835),0,0),0!==d.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);</script><style type=text/css>img.wp-smiley,img.emoji{display:inline!important;border:none!important;box-shadow:none!important;height:1em!important;width:1em!important;margin:0 .07em!important;vertical-align:-.1em!important;background:0 0!important;padding:0!important}</style><link rel=stylesheet id=parent-style-css href=/css/style.css type=text/css media=all><link rel=stylesheet id=brosco-style-css href=/css/style2.css type=text/css media=all><script type=text/javascript src=http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js></script></head><body class="page-template-default group-blog"><div id=page class="hfeed site"><a class="skip-link screen-reader-text" href=#content>Skip to content</a><header id=masthead class=site-header role=banner><div class=header-inside><div class=logo><a href=http://www.fewbytes.com/ title=Fewbytes rel=home><img src=http://www.fewbytes.com/wp-content/uploads/2015/11/fewbytes-logo1.png alt=Fewbytes></a></div><nav id=site-navigation class=main-navigation role=navigation><button class=menu-toggle>Primary Menu</button><div class=menu-top-bar-container><ul id=menu-top-bar class=menu><li id=menu-item-374 class="menu-item menu-item-type-post_type menu-item-object-page current-menu-item page_item page-item-77 current_page_item menu-item-374"><a href=/>Home</a></li><li id=menu-item-89 class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-89"><a href=/posts/>Blog</a></li></ul></div></nav></header><div id=content class=site-content><section id=primary class=content-area><main class=site-main><div class=single-post><div class=container><article class="post type-post status-publish"><header class=entry-header><h1 class=entry-title>How to prevent Continuous Deployment from turning into a Continuous Disaster</h1><div class=entry-meta><time class="entry-date published posted-on">April 13, 2013</time> | <span class=entry-author>Avishai Ish-Shalom</span></div></header><div class=entry-content><p>These days, one the of most frequent request we hear from clients is setting up continuous deployment. Every company wants it, every DevOps related conference has sessions about it. However, newcomers tend to miss one of the key points of CI/CD – it really isn’t an automation problem, it’s a cultural problem. From a pure technical perspective implementing a build-deploy pipeline is fairly simple with current tools and this has been the case for several years. It’s true that new tools make it even easier – a brand new startup can setup CD in under 30 minutes, but automation was not a show stopper for at least 5 years.</p><p>Setting up the automation for deploy-by-commit is easy, but all it does is allow programmers to break production more frequently. When combined with classic dev/ops silos this has a negative explosive effect with catastrophic results.</p><p>To make matters worse, some vendors “ride the wave”, guising their selling pitch with CD/CI sessions which give the impression CD is a problem of tools (which their product solve). There is no product that solves the problem of CD because it is a <strong>problem of methodologies and culture</strong>. This has been discussed at length on various forums (blogs, devops conferences, meetups, talks, lectures, etc.) but is still not as commonly understood as it should be.</p><p>It’s worth taking a moment to explore what kind of bugs we see in production – and what can be changed in an organizations culture and methodologies to prevent them.</p><p>With a gross simplification we divide bugs into 4 categories:</p><ol><li><strong>dumb bugs</strong> - a code that is obviously and clearly wrong.</li><li><strong>implementation bugs</strong> - you have a design that should solve some problem, but the implementation differs from it, many times in a not-so-obvious way. Most concurrency bugs can be classified as implementation bugs.</li><li><strong>integration bugs</strong> - the classic &ldquo;but it worked on my system!&rdquo; bugs. These are bugs that consistently occur when your code base works with some specific external component (e.g. database, external API, etc.) but vanish when the code is tested with another component or in isolation.</li><li><strong>engineering bugs</strong> - every system is engineered to operate within some range of its input signals, some range of load and with some dependencies provided. Another way to describe this is that a system makes assumptions about the nature of the world - which are occasionally discovered to be wrong. Unfortunately, many of these assumptions are implicit or unknown and are sometimes impossible to test in a lab. These bugs also tend to manifest themselves as cascading failures and are notoriously hard to debug.</li></ol><h2 id=tests>Tests</h2><p>When building a CD pipeline, substantial technical efforts should be invested in having automated tests. Unit tests do a great job rooting out dumb bugs and go a long way to reduce the number of implementation bugs. Integration tests (with a proper staging or integration environment) can help screen integration bugs. Testing under load and on a very broad range of inputs can further increase chances of catching implementation and integration bugs and doing A/B testing in production (using beta environment, feature flags and partial deploys) is even better.</p><p>Tests also serve as an incremental spec that ensures you are learning from the mistakes of the past. This means you will add more tests over time increasing the cost and complexity of this part of the pipeline (SOA can help to an extent).</p><p>It&rsquo;s important to observe two things related to testing:</p><ol><li>Despite tests, you will never catch all bugs, some bugs will inevitably reach production</li><li>Testing does not prevent bugs, it exposes them after they were coded</li></ol><h2 id=culture-and-methodologies>Culture and methodologies</h2><p>This is the hardest but most important part of CD. It also has the greatest effect on quality and efficiency and a good systemic way to reduce the amount of <em>integration</em> and <em>implementation</em> bugs that get written in the first place. Culture can help with <em>engineering bugs</em> as well, both in prevention and detection.</p><p>Without going into much detail - there are countless awesome sources on the web, the cultural shift revolves around (among others):</p><ul><li>Small and frequent incremental changes</li><li>Developers touching and understanding production</li><li>Sharing Ops responsibility with Devs</li><li>Eliminating blame</li><li>Ongoing close <strong>cooperation</strong> between teams (in particular, Ops and Devs) from the earliest stages of development</li><li>Automation across the board</li><li>Measurements and visibility as a primary focus</li></ul><p>An often overlooked fact is that culture is coupled to architecture; This is the reason CD thrives with SOA but withers with monolithic architectures.</p><p>Such a cultural shift usually has deeper effects then facilitating CD; It tends to help with prevention of bugs (of all types) and improve reliability and visibility of production. It also seems to cause a preference to small polyglot groups but that&rsquo;s a different discussion altogether. Culture and methodologies are definitely worth investing in - regardless of CD. But if you are building CD without adapting them, then you are surely setting the stage for Continuous Disaster.</p><h2 id=architecture>Architecture</h2><p>As mention above, architecture needs to change too. SOA plays nicely with CD and help break an application into small modules that can change without breaking the entire system. It&rsquo;s also very important to properly separate and abstract data so that code changes don&rsquo;t require schema changes as well.</p><p>I often hear people talking about deployments tools which handle data mutation and schema changes. Personally I believe that this should be solved architecturally, resorting to tooling when all else fails. Schema changes are a common deployment blocker in CI/CD and if you don&rsquo;t take care of it from an architectural perspective risks and effort will (almost always) grow.</p><h2 id=tools>Tools</h2><p>A common mistake is to use different tools for dev, QA, DBs and production. This is a deterrent for developers and other teams from touching production, because they aren&rsquo;t proficient with its toolset. It also makes debugging much harder as some bugs are caused by the tools (and some bugs are simply artifacts of monitoring tools). In short, the complexity of the system is smaller the less tools you have (and by system I mean everything involved in the dev-test-deploy cycle).</p><p>As much as possible, try to use the same tools throughout your organization - if that means deploying with Maven or managing dev machines with Puppet, then so be it. There will be a large initial overhead but it will diminish over time as people become familiar with tools and adapt them to their needs.</p><h2 id=production-visibility-and-resiliency>Production visibility and resiliency</h2><p>Bugs will end up in production and they will become more subtle as tests and quality improves. This means that your production should be debuggable - which usually means visible. This is something that should be factored in from day one, developers need to structure their code in a way that allows easy extraction of meaningful data both during normal operation and during a crisis. Simply plugging in counters and switching to &ldquo;debug&rdquo; log level is not enough.</p><p>The same goes for resiliency; This is a fundamental design requirement and must be considered very early. Note that resiliency isn&rsquo;t about simple hardware failures anymore; HA virtualization solutions and (more so) the shift to clustered architectures has largely alleviated these problems. If a single dead server effects you in 2013 you have more pressing issues than CD. Nowadays, most major failures stem from implementation bugs, engineering bugs and human error. Resiliency is now about fault containment and tolerance.</p><p>The good news is that Culture can help engineers get it right. Software engineers in DevOps culture usually care and understand these needs and design systems accordingly, so even if your production isn&rsquo;t visible or resilient yet it will evolve as culture changes. You will start seeing stuff like monitoring, logging, metrics, fault tolerance, etc. as feature requests from teams all around.</p><h2 id=measuring-yourself>Measuring yourself</h2><p>Cultural change is hard to measure, but there are some measurables worth noting:</p><ul><li>Cardinality of bugs/issues</li><li>Work hours invested in automatable processes</li><li>Number of integration bugs</li><li>Time to detection of production issues</li><li>Time to comprehention of production issues - <strong>not</strong> time to resolution. This is a measurement of how much visibility your production has and how well it is understood by the personnel involved.</li><li>Code changes per deployment - lower is better. There is some debate on how this should be measured, but lines-of-code is a decent place to start</li><li>Rate of metrics per code - again, there is a debate on how to measure this. Metrics/(cardinality of external calls) is a good start.</li></ul><p>There are many other things you can measure and this list isn&rsquo;t applicable everywhere. Culture adapts to sub-cultures and we need to revise our methods with it.</p></div></article></div><nav class="navigation post-navigation" role=navigation><h1 class=screen-reader-text>Post navigation</h1><div class=nav-links style=display:block><div class=nav-previous><a href=/it-is-not-ops/ rel=prev><span class=meta-nav></span>Previous</a></div><div class=nav-next><a href=/using-includerecipe-in-chef-lwrp/ rel=next>Next <span class=meta-nav></span></a></div></div></nav></div></main></section></div><footer id=colophon class=site-footer role=contentinfo><div class=site-info>&copy; Fewbytes</div></footer></div></body></html>